# Открытый студенческий конкурс (хакатон) по быстрому прототипированию решений Интернета вещей


## Содержание

- [Аннотация](#0)
- [Введение](#1)
  - [Инфраструктура типового решения IoT](#2)
  - [Протокол MQTT](#3)
  - [Облачная платформа *Bluemix*](#4)
  - [Краткое описание концепций *Bluemix*](#5)
    - [Развертывание и управление приложением](#6)
    - [Сервисы DevOps Services для *Bluemix*](#7)
    - [Среда визуальной разработки JavaScript приложений Node-RED](#8)
    - [Терминология Node-RED](#9)
    - [Пример использования Node-RED](#10)
- [Arduino](#12)
  - [Аппаратная часть платформы Arduino](#13)
  - [Подключение периферии](#14)
  - [Сенсоры](#15)
    - [Преимущества и недостатки аналогового сигнала](#16)
    - [Преимущества и недостатки цифрового сигнала](#17)
  - [Радиоканал](#18)
    - [Технические характеристики модуля:](#19)
  - [Сборка примера](#20)
  - [Программирование](#21)
    - [Arduino IDE](#22)
    - [Структура программы на языке C++ для Arduino](#23)
    - [Написание программы для отправки данных сенсоров по радиоканалу](#24)
      - [Синтаксис](#25)
      - [Параметры](#26)
      - [Возвращаемое значение](#27)
      - [Замечание](#28)
- [Raspberry Pi](#29)
  - [Получение данных с Arduino](#30)
  - [Создание приложения в *Bluemix*](#31)
  - [Отправка данных в *Bluemix*](#32)
  - [Получение данных из *Bluemix*](#33)
- [Визуализация](#34)
  - [Сервер](#35)
  - [Клиент](#36)
    - [График температуры](#37)
    - [Угол поворота](#38)
    - [Кнопка](#39)
- [Аналитическая обработка данных](#40)
  - [Работа с сервисом dashDB](#41)
    - [Добавление сервиса в проект](#42)
    - [Создание таблицы](#43)
    - [Запуск потоковой записи первичных данных](#44)
    - [Удаление данных из таблиц](#45)
    - [Создание скрипта в RStudio](#46)
    - [Запись скрипта в файловую систему окружения dashDB](#47)
  - [Запуск скрипта по расписанию из node-red](#48)
  - [Визуализация предиктивных данных](#49)
- [Описание оборудования лаборатории Интернета вещей](#50)


## Аннотация <a name="0"></a>

> Всем участникам соревнования предоставляется необходимое оборудование для реализации прототипа решения Интернета вещей: датчики, микрокомпьютеры, актуаторы, радиомодули. Подробное описание оборудование приведено в приложении.

> В ходе соревнования типовой проект может быть использован для построения широкого спектра решений: 

> - в агропромышленном комплексе; 

> - в городском хозяйстве; 

> - на производстве; 

> - в медицине;

> - транспорте и других областях.

> Задача для участников соревнования ставится следующим образом: **используя имеющийся набор датчиков, микрокомпьютеры, облачные сервисы и приложения, разработать прототип распределенной системы Интернета вещей.** 

> Допускается применение иных облачных платформ и аппаратно-программных решений. Прототип системы будет собран на специальном стенде в лаборатории IoT МГТУ им. Баумана, где он может быть продемонстрирован жюри. 



## Введение <a name="1"></a>

Воплощение потенциала идей, заложенных в концепцию Интернета вещей, способно существенно изменить уклад современной экономики. Благодаря внедрению масштабируемых облачных решений, использованию большого количества датчиков и распределенных микропроцессорных систем уже в ближайшее время могут быть созданы прорывные решения в таких областях, как: транспорт, сельское хозяйство, промышленное производство, здравоохранение, социальная сфера, быт и других. Все большее количество компаний обращает внимание на применение идей и технологий Интернета вещей для внедрения аналитики их деятельности и поиска новых возможностей для продуктов и услуг.

> *Интернет вещей (англ. Internet of Things, IoT) — это концепция вычислительной сети физических объектов («вещей»), оснащённых встроенными технологиями для взаимодействия друг с другом или с внешней средой.*
> 

Перечислим некоторые интересные факты:
-   По оценкам специалистов, к 2020 году к сети Интернет будет подключено до 50 млрд устройств, 20 млрд из них будут задействованы в инфраструктуре IoT.

![Прогноз количества устройств, подключенных к сети Интернет](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro01.jpg)

-   До 90% данных, анализируемых устройствами Интернета вещей ранее не подвергались обработке.
-   До 60% данных, получаемых устройствами Интернета вещей, остаются актуальными лишь несколько миллисекунд.
-   В настоящее время только 0,1% устройств, способных выполнять полезную вычислительную нагрузку, подключены к сети.



****
### Инфраструктура типового решения IoT <a name="2"></a>

Под типовым решением Интернета вещей в данном конкурсе понимается распределенная кибер-физическая система, интегрирующая вычислительные ресурсы в физические процессы. В такой системе должны быть реализованы следующие основные функции:

-   Сбор первичных данных с помощью сенсоров, расположенных в непосредственной близости от реальных объектов.
-   Управление объектами через актуаторы, подключенные к микрокомпьютерам.
-   Передача первичных данных от микрокомпьютеров в вычислительный хаб и  в обратном направлении.
-   Первичная обработка данных в вычислительном хабе, формирование     пакетов данных для передачи их в облако.
-   Получение и хранение данных в облаке.
-   Аналитическая обработка в облаке и формирование ключевых показателей эффективности (KPI) на основе данных об объектах, данных от сторонних источников, исторических данных.
-   Визуализация данных и результатов анализа на различных платформах: мобильных устройствах, носимой электронике, планшетах, компьютерах,     мониторах и пр.
-   Прием команд от внешних управляющих консолей.
-   Принятие решений на основе KPI и команд, выработка управляющих и информационных сообщений для актуаторов.
-   Передача управляющих сообщений в вычислительные хабы.

Примером подобной системы является структура, представленная на следующем рисунке.

![Пример решения Интернета вещей](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro03.png)
**Пример решения Интернета вещей**


В примере использовано оборудование:

-   Светодиоды в качестве имитации актуаторов.
-   Датчики для регистрации необходимых параметров объекта (например,
    датчики температуры и влажности).
-   Микрокомпьютеры Arduino Uno для управления актуаторами и получения
    данных от датчиков.
-   Беспроводные радиочастотные модули RF 433 МГц для коммутации
    микрокомпьютеров с вычислительным хабом.
-   Плата расширения Gove для подключения датчиков, актуаторов и RF
    модулей к микрокомпьютеру.
-   Микрокомпьютер RaspberryPi 2 в качестве вычислительного хаба.
-   Облачная платформа IBM Bluemix для реализации сервисов хранения,
    аналитической обработки и визуализации данных.

Система работает следующим образом. Информация от датчиков через соединительные разъемы на платах Grove передается в микрокомпьютер Arduino. Прием информации осуществляется под управлением программы на языке C с заданной разработчиком периодичностью. Собранные данные собираются в пакеты и снабжаются идентификаторами номера датчика.

![Функциональная схема проекта](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/Intro031.png)
**Функциональная схема проекта**


Через радиомодуль `RF433` данные от многих микрокомпьютеров передаются в вычислительный хаб (`RaspberryPi`). Хаб формирует пакеты `MQTT` и передает их в облако Bluemix для хранения и обработки. Обратно из облака хаб получает команды управления актуаторами, в качестве которых используются светодиоды. Таким образом, по команде выполняется включение и выключение светодиодов.

Данные из MQTT пакета поступают в брокер в составе сервиса IoT Foundation. Настроечные параметры подключенных устройств сохраняются в базе данных Cloudant.  Подписчиком данных является приложение Node-Red, которое позволяет манипулировать ими с помощью простых визуальных средств. Множество примитивных обрабатывающих блоков (нодов) представляют собой JavaScript приложения, связанные между собой потоками данных. 

Таким образом JavaScript приложения в Node-Red выполняют сохранение полученных данных в базе dashDB. Другое приложение JavaScript запускает скрипт на языке R, который выполняет регрессионный анализ данных от датчиков и определяет предиктивное значение для некоторого предстоящего момента времени. 

Полученные результаты предиктивного анализа также сохраняются в базе dashDB. По полученным первичным данным и предиктивным данным строятся графики, которые визуализируются на html странице, доступной для просмотра в броузере.

На странице воспроизводится кнопка оператора, при нажатии на которую формируется MQTT пакет, который через брокер поступает в хаб RaspberryPi и приводит к переключению состояния первого светодиода. В случае превышения предиктивных показаний установленного предела автоматически формируется другой MQTT пакет, который приводит к переключению второго светодиода. 


****

### Протокол MQTT <a name="3"></a>

MQTT (*Message Queue Telemetry Transport*) - упрощенный протокол сетевого уровня для обмена сообщениями между устройствами. Этот протокол работает поверх стека TCP/IP и разработан для преодоления проблем, связанных с подключением быстро растущего числа датчиков, микрокомпьютеров, приводов, телефонов, планшетов. В настоящее время MQTT является наиболее распространенным протоколом для организации IoT инфраструктуры.

MQTT организован по принципу издатель/подписчик(*publisher/subscriber*): издатель (устройства типа *publishers*) является отправителем сообщения, которое публикуется в централизованном сервисе (брокере сообщений), а подписчик (устройства типа *subscriber*) получает сообщение из брокера. Для использования брокера MQTT необходимо пройти процедуру подписки на определенные темы публикуемых сообщений.

![Диаграмма последовательностей для одного подписчика](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro02.png)
**Диаграмма последовательностей для одного подписчика**

В процессе работы издатель передает данные с указанной темой сообщения, которое сопоставляется брокером с темами подписчиков. В случае совпадения, каждый из них получает экземпляр данных.

Наиболее распространенной реализацией протокола MQTT является библиотека Paho MQTT (http://www.eclipse.org/paho). Библиотека реализована для наиболее популярных языков программирования: C/C++, Java, Javascript, Python, Lua, Go, C\#.


![Сравнение протоколов MQTT и HTTPS](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/mqtt_table.png)
**Сравнение протоколов MQTT и HTTPS**

Небольшие накладные расходы, связанные с хорошо продуманным форматом заголовков, позволяют эффективно применять этот протокол для решений Интернета вещей. В таблице показаны результаты экспериментального сравнения протоколов MQTT и HTTPS. Эксперименты [показывают](http://stephendnicholas.com/posts/power-profiling-mqtt-vs-https), что данный протокол обладает небольшими накладными расходами на стороне устроства, что позволяет сократить расход энергии аккумуляторной батареи и увеличивает количество передаваемых в единицу времени сообщений. В связи с этим протокол MQTT будет использован в данном проекте для транспортировки пакетов данных и команд между распределенными устройствами Интернета вещей и аналитическими средствами облачной платформы IBM Bliemix. 


****

### Облачная платформа *Bluemix* <a name="4"></a>

***Bluemix*** — это открытое облачное предложение типа PaaS
(*Platform-as-a-Service*) на базе проекта с открытым исходным кодом Cloud Foundry. Эта платформа предназначена для разработки и хостинга приложений, а также упрощения задач по управлению инфраструктурой. Она позволяет быстро создавать и развертывать приложения, а также управлять ими.

***Bluemix*** обеспечивает следующие возможности:

-   быстрое и инкрементное составление приложений из сервисов;
-   непрерывное внесение изменений в приложения и обеспечение постоянной     доступности;
-   поддержка высокоспециализированных моделей программирования и сервисов для конкретных рабочих нагрузок;
-   встраивание высокой степени управляемости в сервисы и приложения;
-   оптимизация и эластичная адаптация к рабочей нагрузке.


![Каталог компонентов Bluemix](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro04.jpg)
**Каталог компонентов Bluemix**


Платформа *BlueMix* достигает этих целей посредством абстрагирования и скрытия большинства сложностей, традиционно сопутствующих хостингу приложений в облаке и управлению ими в облачной среде. *Bluemix* может быть использована разработчиками для создания и применения самых разных приложений, включая веб-приложения, мобильные приложения, приложения для работы с большими данными, приложения для разумных устройств и т.д. *Bluemix* поддерживает разработку на популярных языках программирования и средах разработки. Java-технологии, средства создания серверных частей для мобильных приложений, мониторинг приложений, технологии с открытым исходным кодом и т. д. — все эти возможности
доступны в облаке как сервисы.

Каталог *Bluemix* содержит большую часть из того, что необходимо для быстрого начала работы, большое количество шаблонов, заранее сконфигурированны наборов сервисов, сред исполнения и примеров кода, готовых к использованию:

-   сред исполнения, в том числе: Liberty for Java, Node.js, Ruby on Rails;
-   веб-сервисов и сервисов приложений, в том числе: Data/Session Cache,  ElasticMQ, Decision, SSO, Log Analysis, Redis, RabbitMQ, Twilio;
-   мобильных сервисов, в том числе: push-уведомлений, Cloud Code,     Mobile Application Management, Mobile Quality Assurance;
-   сервисов управления данными, в том числе: MongoDB, реляционной базы данных от IBM, JSON-базы данных от IBM, MySQL, PostgreSQL, MobileData, Mobile Sync, BLU Data Warehouse, MapReduce;
-   сервисов мониторинга и анализа;
-   сервисов DevOps Services (прежнее название: JazzHub).


****

### Краткое описание концепций *Bluemix* <a name="5"></a>


В терминологии *Bluemix* приложение (*application*) — это созданный вами артефакт, т. е. весь программный код (исходный код или исполняемые двоичные файлы), который необходимо запустить или на который необходимо сослаться в процессе исполнения. Мобильные приложения выполняются за пределами среды *Bluemix* и используют сервисы *Bluemix*, представленные приложениями. В случае веб-приложений приложение — это код, загруженный на платформу *Bluemix* с целью хостинга. Кроме того, платформа *Bluemix* способна осуществлять хостинг программного кода приложения, который вы хотите выполнять на внутреннем сервере в среде на базе контейнера.

На рисунке показаны принципы взаимодействия *Bluemix* с клинтскими приложениями.


![Принципы взаимодействия *Bluemix* с клинтскими приложениями](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro05.jpg)
**Принципы взаимодействия *Bluemix* с клинтскими приложениями**


***Сервис (service)*** — это код, работающий на платформе *Bluemix* и предлагающий некоторую функциональность, которую могут использовать приложения. Это может быть готовый сервис, используемый непосредственно — например, push-уведомления для мобильных приложений или эластичное кэширование для веб-приложения. Вы также можете создавать собственные сервисы в диапазоне от простых служебных функций до сложной
бизнес-логики.

***Организация (organization) и пространство (space)*** — это организационные единицы инфраструктуры, способные хранить и отслеживать ресурсы приложения. Организация содержит домены (domain), пространства и пользователей. Пространство содержит приложения и сервисы. По умолчанию используется три пространства: Development (разработка), Production (производство) и Staging (подготовка). Для приложений, которым требуется среда типа PaaS, предоставляются buildpack-пакеты, каждый из которых представляет собой набор скриптов для подготовки кода к исполнению на целевой PaaS-платформе. Buildpack-пакеты, которые включают необходимую вашим приложениям среду исполнения и могут также содержать специализированные инфраструктуры, упрощают развертывание приложения в облаке по сравнению с самостоятельной установкой и конфигурированием среды исполнения.

Использование сервисов в *Bluemix* включает три этапа:
1.  Сообщите платформе *Bluemix*, что вам требуется новый экземпляр сервиса и какое конкретное приложение будет использовать этот новый экземпляр.
2.  *Bluemix* автоматически инициализирует новый экземпляр этого сервиса и свяжет его с приложением.
3.  Приложение взаимодействует с сервисом.

***Пакеты сервисов (Service bundles)*** — это коллекции API-интерфейсов, используемых в конкретных областях. Например, пакет Mobile Services включает сервисы MobileData, Cloud Code, Push и Mobile Application Management. Доступные сервисы и среды исполнения представлены в каталоге Bluemix. Кроме того, вы можете зарегистрировать собственные сервисы.

#### Развертывание и управление приложением <a name="6"></a>

Чтобы развернуть свое приложение, необходимо загрузить его в среду *Bluemix* и указать, сколько экземпляров этого приложения должно исполняться, а затем сконфигурировать *Bluemix*, введя необходимую информацию для поддержки этого приложения.

В случае мобильного приложения среда *Bluemix* содержит артефакт, который представляет серверную часть мобильного приложения — набор сервисов, который использует приложение для взаимодействия с сервером. *Bluemix* поддерживает серверные компоненты мобильного приложения, взаимодействующие с сервисами PushWorks, Cloud Code и Mobile Data, непосредственно из пользовательского интерфейса *Bluemix*.

В случае веб-приложения необходимо предоставить в *Bluemix* соответствующую информацию о среде исполнения и среде разработки, чтобы платформа смогла сформировать надлежащую инфраструктуру для исполнения этого приложения.

При развертывании приложений и управлении ими можно использовать инструмент командной строки cf, веб-интерфейс *Bluemix* или сервисы DevOps Services.

Браузерные и мобильные клиенты — а также другие приложения, развернутые на платформе *Bluemix* и выполняющиеся за ее пределами — взаимодействуют с приложениями, работающими на платформе *Bluemix*, через API-интерфейсы типа REST/HTTP. Каждый клиентский запрос маршрутизируется к одному из экземпляров приложения или составляющих его сервисов. Среды исполнения приложений в *Bluemix* изолированы друг от друга даже тогда, когда они находятся на одной и той же физической машине.

В ходе управления приложениями можно запускать, останавливать, перезапускать экземпляры приложения (или, в случае веб-приложения, изменять их количество), а также изменять объем памяти, используемый приложением. Ключевая конструктивная особенность *Bluemix* — отличные показатели при хостинге масштабируемых приложений и артефактов приложений. На данный момент эта платформа не масштабирует приложение автоматически в соответствии с нагрузкой, поэтому этим процессом необходимо управлять самостоятельно посредством создания или удаления экземпляров при изменении рабочей нагрузки. По этой причине ваши приложения должны сохранять все персистентные данные за пределами приложения в одном из сервисов хранения данных, предоставляемых платформой *Bluemix*. При повторном развертывании приложения после обновления используется тот же процесс, что и при начальном развертывании. *Bluemix* останавливает все исполняющиеся экземпляры и переводит новые экземпляры в рабочее состояние автоматически.

#### Сервисы DevOps Services для *Bluemix* <a name="7"></a>

При использовании DevOps Services требуется лишь несколько простых шагов для организации взаимодействия с другими специалистами с целью планирования, отслеживания и создания программного обеспечения в облаке. Вы можете воспользоваться встроенным в браузер редактором программного кода, который DevOps Services предоставляет для разработки приложений, или использовать DevOps Services с Eclipse, с VisualStudio или с инструментом командной строки Git для написания кода приложения и развертывания его на платформе BlueMix.

При работе с пользовательским интерфейсом, который помогает разработчику быстро добавлять сведения "кто", "что" и "когда" для своего рабочего проекта, требуется потратить всего несколько минут на задание дат, документирование первого сценария применения, назначение одной-двух задач и переход непосредственно к написанию программного кода.

DevOps Services включает встроенные средства управления исходным кодом — Jazz SCM и хостинговый Git. Каждый проект получает свой собственный репозиторий DevOps Services и рабочее пространство, в котором участники этого проекта могут регистрироваться свои изменения, ассоциировать изменения программного кода и просматривать историю недавних изменений. Кроме того, вы можете создать проект DevOps Services и указать на свой репозиторий GitHub.

Вы также можете с легкостью связать элементы работы с изменениями кода в GitHub. Кроме того, для написания кода в Git вы можете использовать имеющиеся у вас инструменты.

Типичными сценариями использования ресурса DevOps Services являются:

-   Создание приложения для анализа данных социальных сетей с использованием Node.js, Node-RED, Express, sentiment и ntwitter.
-   Создание приложения для создания интерактивных опросов в реальном     времени с использованием Node.js, Node-RED, Express, AngularJS и MongoDB.
-   Построение сервисов уведомления с использованием Node.js, Node-RED и MongoDB.
-   Создание приложений для управления аппаратными устройствами c использованием Node-RED и IoT компонент.

#### Среда визуальной разработки JavaScript приложений Node-RED <a name="8"></a>

**Node-RED** - это визуальная drag-and-drop среда разработки JavaScript рантаймов для IoT (неблокирующих приложений, управляемых событиями). Благодаря большому количеству примитивов и возможности быстрой визуальной настройки и созданию новых компонентов, в том числе непосредственно на языке JavaScript, Node-RED может быть использована как непрофессиональными пользователями, так и профессиональными разработчиками для ускорения создания веб-приложений в облаке. Это позволяет использовать Node-RED для взаимодействия с недорогими аппаратными платформами в рамках подхода IoT, перенося основную часть вычислительной нагрузки на облачную платформу. Помимо этого все созданные рантаймы могут быть объединены в библиотеки решений и впоследствии перенесены в другие проекты благодаря функциям экспорта и
импорта.

#### Терминология Node-RED <a name="9"></a>

*Нод (node)* - функционально законченный блок.

*Поток обработки (flow)* - цепь соединенных нодов и соответствующий им конфигурационный нод.

*Входной нод (input node)* - нод, принимающий внешние данные и задающий начало потоку обработки (flow). Входной нод имеет один или несколько выходных портов (output ports).

*Выходной нод (output node)* - нод, завершающий поток обработки и передающий результаты во внешнюю среду.

*Функциональный нод (function node or query node)* - нод, находящийся внутри потока обработки и имеющий один входной порт и один или несколько выходных портов.

*Конифигурационный нод (config node)* - нод, содержащий конфигурационную информацию, используемую в других нодах. Конфигурационный нод не связан портами с другими типами нодов.

*Набор нодов (node set)* - ноды, включенные в связанные js/html файлы (пары соответствующих друг другу файлов, содержащих связанный код JavaScript и HTML). Ошибка в js/html паре приводит к неработоспособности всех нодов набора.

*Модуль нодов (node module)* - множество связанных js/html файлов (и, соответственно, наборов нодов), где каждая пара описана в package.json файле.

*Пакет нодов (node pack)* - коллекция связанных по функциональности нодов, которые могут быть использованы разработчиком в рамках одного проекта.

![Основное окно проекта в Node-RED](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro06.jpg)
**Основное окно проекта в Node-RED**


#### Пример использования Node-RED <a name="10"></a>

Примером эффективного применения технологии Node-RED может служить проект, на разработку которого требуется около 15 минут. Приложение позволяет автоматически отслеживать текущее местоположение мобильного устройства, определяет прогноз погоды и сообщает о нем через твиттер самому пользователю.

![Поток обработки для информирования о прогнозе погоды](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/intro07.jpg)
**Поток обработки для информирования о прогнозе погоды**



Решение работает следующим образом:

-   Приложение на мобильном телефоне передает телеметрическую информацию о положении устройства в обрабатывающий поток Node-RED.
-   Телеметрическая информация о местоположении преобразуется в twitter сообщение.
-   Сообщение используется для доступа к прогнозу погоды в ноде Forecast.io.
-   Полученный прогноз форматируется в сообщение twitter.
-   Сообщение посылается на твиттер аккаунт пользователя и отображается на мобильной платформе.

Приведенный пример позволяет реализовать логику взаимодействия с использованием протоколов MQTT, HTTP и Twitters API без глубокого погружения в их технические особенности.



# Arduino <a name="12"></a>
Arduino — это электронный конструктор и удобная платформа быстрой разработки электронных устройств для новичков и профессионалов. Платформа пользуется огромной популярностью во всем мире благодаря удобству и простоте языка программирования, а также открытой архитектуре и программному коду. Устройство программируется через USB без использования программаторов.

![Плата Arduino](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino01.jpg)
**Плата Arduino**

Arduino позволяет компьютеру выйти за рамки виртуального мира в физический и взаимодействовать с ним. Устройства на базе  Arduino могут получать информацию об окружающей среде посредством различных датчиков, а также могут управлять различными исполнительными устройствами.

****
## Аппаратная часть платформы Arduino <a name="13"></a>
Существует несколько версий платформ Arduino. Uno, как и предыдущая версия Duemilanove построены на микроконтроллере Atmel ATmega328. Старые версии платформы Diecimila и первая рабочая Duemilanoves были разработаны на основе Atmel ATmega168, более ранние версии использовали ATmega8. 
Arduino Mega2560, в свою очередь, построена на микроконтроллере ATmega2560.

****
## Подключение периферии <a name="14"></a>
Отличительной особенностью Arduino является наличие плат расширения, так называемых shields или просто «шилдов». Это дополнительные платы, которые ставятся подобно слоям бутерброда поверх Arduino, чтобы дать ему новые возможности. Так например, существуют платы расширения для подключения к локальной сети и интернету (Ethernet Shield), для управления мощными моторами (Motor Shield), для получения координат и времени со спутников GPS (модуль GPS) и многие другие.

![Принцип бутерброда](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino02.jpg)
**Принцип бутерброда**

Для Arduino существует огромное количество различных датчиков, позволяющих проводить различные эксперименты и собирать информацию об окружающей среде. Чтобы удобно

**Плата расширения GROVE**

****
## Сенсоры <a name="15"></a>
GROVE - это не только плата расширения, но и целая линейка датчиков и переферии. 
Для примера предлагается осуществить подключение двух датчиков.
Датчик угла поворота подключается к контакту A0 на плате GROVE. 
A - означает аналоговый вход микроконтроллера, а 0 - номер.

![Подключение датчика угла поворота](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino04.jpg)
**Подключение датчика угла поворота**

При использовании аналогового сигнала, показания датчика передаются в виде переменного напряжения на сигнальном проводе. Сигнальное напряжение может принимать значение от 0 В до напряжения питания. 

### Преимущества и недостатки аналогового сигнала <a name="16"></a>

Преимуществом сенсоров с аналоговым сигналом является крайняя простота их использования с Arduino. Кроме того, поскольку показания датчика можно считывать «из коробки» всего одной командой, драгоценные килобайты памяти на микроконтроллере не расходуются на хранение алгоритма расшифровки протокола, присущего цифровым сенсорам.
Главным недостатком аналогового сигнала является неустойчивость к внешним шумам. Если провод от сенсора до микроконтроллера будет достаточно длинным, он начнёт работать как антенна и улавливать внешние электромагнитные поля: провод сам будет влиять на выходное напряжение и тем самым искажать показания. Поэтому разумный предел длины провода для аналогового сенсора — не более 50 с.Чтобы уменьшить влияние помех на полезный сигнал можно воспользоваться усреднением. Так как помехи носят случайный характер, они будут влиять на полезный сигнал тем меньше, чем больше выборок используется для усреднения.
****
Вторым будет датчик температуры. Подключаем его к контакту A1.

![Датчик температуры](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino05.jpg)
**Датчик температуры**

****

### Преимущества и недостатки цифрового сигнала <a name="17"></a>

Преимуществом сенсоров с цифровым сигналом и всего двумя состояниями является крайняя простота их использования с Arduino.
Однако, если речь идёт о цифровом сенсоре с множеством градаций измеряемой величины, их использование с Arduino не так тривиально, как бинарных или аналоговых: необходимо реализовать расшифровку данных, что требует определённых усилий, а также занимает память микроконтроллера.
Поскольку возможных значений в цифровом сигнале всего 2, а возможные отклонения в напряжении «округляются» микроконтроллером в ближайшую сторону, такие сенсоры можно подключать с помощью достаточно длинных (много метров) проводов, не опасаясь искажения сигнала из-за влияния на провод внешних электромагнитных полей.
****

## Радиоканал <a name="18"></a>
Для организации беспроводной связи в данном проекте используются радиомодули RF 315/433. Радиопередатчик подключаем к цифровому выходу D2 платы расширения GROVE.

![Радиоканал](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino06.jpg)
**Радиоканал**

****
### Технические характеристики модуля <a name="19"></a>

-   Рабочее напряжение: 3 В - 12 В. Чем больше напряжение, тем больше мощность передатчика.
-   Рабочая сила тока: максимально - 40 мА, минимально - 9 мА.
-   мобильных сервисов, в том числе: push-уведомлений, Cloud Code,     Mobile Application Management, Mobile Quality Assurance;
-   Режим резонанса: (SAW).
-   Режим модуляции: ASK.
-   Рабочий частотный диапазон: 315 МГц или 433 МГц.
-   Мощность: 25 мВ (315 МГц при 12 В).
-   Погрешность частот: +150 кГц (макс.).
-   Скорость: не больше 10 Кб/с.

****
## Сборка примера <a name="20"></a>
Приступим к сборке демо-примера. Мы будем получать информацию с двух датчиков и отправлять ее по радиоканалу. Для этого нам потребуется следующий набор:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino7.png)

Берем плату Arduino UNO  и располагаем ее перед собой. 

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino8.png)

На нее нужно установить плату Grove. 

Внимание! Убедитесь, что все ножки попали в соответствующие выводы на плате Arduino. Если соединить неправильно, то можно впоследствии сжечь микроконтроллер

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino9.png)

Небольшим усилием соедининяем две платы до упора.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino10.png)

Далее берем датчик угла поворота.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino11.png)

Он подключается в любой из аналоговых выходов на плате GROVE. Подключим его к A0.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino12.png)

Аналогично подключаем датчик температуры к аналоговому выходу A1.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino13.png) 
 
![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino14.png) 

Передатчик подключается в цифровой вывод D2.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino15.png) 

На этом сборка железной части завершена.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino16.png) 

Теперь необходимо подключить Arduino к компьютеру и перейти к программированию

Подключение платы к компьютеру осуществляется через USB - разъем.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino17.png) 

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino18.png)

****
## Программирование <a name="21"></a>
Микроконтроллер на плате программируется при помощи языка Arduino (основан на языке Wiring) и среды разработки Arduino (основана на среде Processing). Проекты устройств, основанные на Arduino, могут работать самостоятельно, либо же взаимодействовать с программным обеспечением на компьютере (напр.: Flash, Processing, MaxMSP). 

### Arduino IDE <a name="22"></a>

Среда разработки Arduino состоит из встроенного текстового редактора программного кода, области сообщений, окна вывода текста(консоли), панели инструментов с кнопками часто используемых команд и нескольких меню. Для загрузки программ и связи среда разработки подключается к аппаратной части Arduino.

![Среда программирования Arduino IDE](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino19.jpg)
**Среда программирования Arduino IDE**

Программа, написанная в среде Arduino, называется скетч. Скетч пишется в текстовом редакторе, имеющем инструменты вырезки/вставки, поиска/замены текста. Во время сохранения и экспорта проекта в области сообщений появляются пояснения, также могут отображаться возникшие ошибки. Окно вывода текста(консоль) показывает сообщения Arduino, включающие полные отчеты об ошибках и другую информацию. Кнопки панели инструментов позволяют проверить и записать программу, создать, открыть и сохранить скетч, открыть мониторинг последовательной шины:

| Кнопка   |      Действие |
|----------|:-------------:|
| ![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino20.JPG) |  Проверка программного кода на ошибки, компиляция. |
| ![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino21.JPG) |    Компилирует программный код и загружает его в устройство Arduino.   |
| ![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/arduino22.JPG) | Открытие мониторинга последовательной шины (Serial monitor). |
### Структура программы на языке C++ для Arduino <a name="23"></a>
Рассмотрим простой пример мигания светодиодом:
```
void setup()
{
}
 
void loop()
{
}
```
В данном случае у нас 2 функции с именами setup и loop. Их присутствие обязательно в любой программе на C++ для Arduino.Они могут ничего и не делать, но должны быть написаны. Иначе на стадии компиляции вы получите ошибку.

### Написание программы для отправки данных сенсоров по радиоканалу <a name="24"></a>

В первую очередь задаем в коде константу GROUP_ID с номером вашей группы. Это ваш уникальный идентификатор в радиоканале. Так как все передатчики работают на одной частоте, то в первую очередь необходимо выделять среди прочих данные именно с ваших датчиков. 
Например, для первой группы это делается следующим образом: 

```
#define GROUP_ID 1 
```
Для работы с радиомодулем нужно подключить библиотеку RCSwitch.
```
#include "RCSwitch.h"
RCSwitch sender = RCSwitch();
```

В setup() производим включение радиомодуля, подключенного к контакту D2 платы GROVE.
```
#define TRANSMITTER_PIN 2
void setup() {
  sender.enableTransmit(TRANSMITTER_PIN);
  sender.setRepeatTransmit(4);
}
```
Для считывания значений аналогового датчика температуры используется стандартная функция analogRead()
#### Синтаксис <a name="25"></a>
analogRead(pin)
#### Параметры <a name="26"></a>
pin: номер порта аналогового входа с которого будет производиться считывание (0..5 для большинства плат, 0..7 для Mini и Nano и 0..15 для Mega)
#### Возвращаемое значение <a name="27"></a>
int (0 to 1023)
#### Замечание <a name="28"></a>
Если аналоговый вход не подключен, то значения возвращаемые функцией analogRead() могут принимать случайные значения.

Код для датчика температуры:
```
#define TEMPERATURE_SENSOR A1

#define B 3975 // идентификатор используемого термистора
int getTemperature() {
  int value = analogRead(TEMPERATURE_SENSOR);
  float resistance = (float)(1023 - value) * 10000 / value;
  float temperature = 1 / (log(resistance / 10000) / B + 1/298.15) - 273.15;
  return temperature;
}
```

Код для датчика угла поворота:
```
#define ROTARY_ANGLE_SENSOR A0

#define ADC_REF 5 // значение питания платы Arduino 5V
#define FULL_ANGLE 300 // Максимальное значение угла поворота
#define GROVE_VCC 5 // значение питания платы GROVE 5V

int getAngle() {
  int value = analogRead(ROTARY_ANGLE_SENSOR);
  float voltage = (float)value * ADC_REF / 1023;
  return voltage * FULL_ANGLE / GROVE_VCC;
}
```
Функция для кодирования сообщения, передаваемого по радиоканалу.

```
/*
Формат данных:
  group - идентификатор вашей группы
  n - номер датчика
  data - текущее показание
*/
unsigned long encode(byte group, byte n, int data) {
  return (unsigned long)group << 24 | (unsigned long)n << 16 | data & 0xffff;
}
```

Основной цикл программы:
```
#define GROUP_ID 1
void loop() {
  int temp = getTemperature(); // считывание значения температуры
  int degree = getAngle();     // считывание значения угла поворота
  sender.send(encode(GROUP_ID, 0, temp), 32); //кодирование и отправка температуры
  delay(500); // задержка 500 мс
  sender.send(encode(GROUP_ID, 1, degree), 32); //кодирование и отправка угла поворота
  delay(500); 
}
```

Полный код тестовой программы для Arduino:
```
#include "RCSwitch.h"

#define GROUP_ID 1 // идентификатор вашей группы
#define TRANSMITTER_PIN 2 // номер контакта, к которому подключен передатчик (D2)
#define TEMPERATURE_SENSOR A1 // номер контакта, к которому подключен датчик температуры
#define ROTARY_ANGLE_SENSOR A0 // номер контакта, к которому подключен датчик угла поворота 


RCSwitch sender = RCSwitch();

/*
Формат данных:
  group - идентификатор вашей группы
  n - номер датчика
  data - текущее показание
*/
unsigned long encode(byte group, byte n, int data) {
  return (unsigned long)group << 24 | (unsigned long)n << 16 | data & 0xffff;
}

#define B 3975 // идентификатор используемого термистора
int getTemperature() {
  int value = analogRead(TEMPERATURE_SENSOR);
  float resistance = (float)(1023 - value) * 10000 / value;
  float temperature = 1 / (log(resistance / 10000) / B + 1/298.15) - 273.15;
  return temperature;
}

#define ADC_REF 5 // значение питания платы Arduino 5V
#define FULL_ANGLE 300 // Максимальное значение угла поворота
#define GROVE_VCC 5 // значение питания платы GROVE 5V

int getAngle() {
  int value = analogRead(ROTARY_ANGLE_SENSOR);
  float voltage = (float)value * ADC_REF / 1023;
  return voltage * FULL_ANGLE / GROVE_VCC;
}

void setup() {
  sender.enableTransmit(TRANSMITTER_PIN);
  sender.setRepeatTransmit(4);
}

void loop() {
  int temp = getTemperature(); // считывание значения температуры
  int degree = getAngle();     // считывание значения угла поворота
  sender.send(encode(GROUP_ID, 0, temp), 32); //кодирование и отправка температуры
  delay(500); // задержка 500 мс
  sender.send(encode(GROUP_ID, 1, degree), 32); //кодирование и отправка угла поворота
  delay(500); 
}

```
## Raspberry Pi <a name="29"></a>
> Raspberry Pi — одноплатный компьютер размером с банковскую карту, изначально разработанный как бюджетная система для обучения информатике, 
впоследствии получивший намного более широкое применение и популярность, чем ожидали его авторы. 
>

![Raspberry PI](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry01.jpg)
**Raspberry PI**

### Описание
На плате размером с кредитную карту вы найдёте всё то, что можете найти в обычном персональном компьютере: процессор, оперативную память, 
разъёмы HDMI, USB, Ethernet, аналоговые аудио- и видеовыходы. Кроме того, на плате расположены 40 контактов ввода/вывода общего назначения. К 
ним вы сможете подключать периферию для взаимодействия с внешним миром: исполнительные устройства вроде реле и сервомоторов или же любые 
сенсоры; в общем всё, что работает от электричества.

Штатной операционной системой для Raspberry Pi является Linux. Она устанавливается на micro-SD карту, а та в свою очередь — в специальном 
слоте на плате. Если вы не знаете Linux, не стоит пугаться. Напротив: этот компьютер — прекрасная возможность во всём разобраться. Потерять 
данные или сильно напортачить с настройками не так страшно, ведь образ на SD-карте можно восстановить за считанные минуты. После этого можно 
продолжить эксперименты с чистого листа или с определённой контрольной точки.

#### Порты и аппаратные интерфейсы
Для подключения монитора или телевизора используются композитный видеовыход или разъём HDMI. Кроме того, заводские OEM ЖК-экраны могут быть 
подключены через интерфейс DSI.
Raspberry Pi 2 Model B предоставляет 4 USB-порта, объединённых внутренним хабом. К ним, помимо всего прочего, можно подключить клавиатуру и 
мышь.

В качестве низкоуровневых интерфейсов доступны:

- 40 портов ввода-вывода общего назначения
- UART (Serial)
- Шина I²C/TWI
- Шина SPI с селектором между двумя устройствами
- Пины питания: 3,3 В, 5 В и земля

Колонки или наушники могут быть подключены через стандартное гнездо для 3,5 мм джеков. Также звук может передаваться через интерфейс HDMI.
На Raspberry Pi Model B+ доступен Ethernet-адаптер на 10/100 Мбит с выходом на стандартное гнездо 8P8C (RJ45).

#### Распиновка платы
![Распиновка Raspberry](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry02.jpg)
**Распиновка Raspberry**

#### Питание
Raspberry Pi Model B+ может быть запитана через microUSB-кабель или через пины питания.
Номинальное напряжение питания — 5 В. Компьютер потребляет до 800 мА без внешних устройств.
Аппаратный выключатель питания на плате отсутствует. Для включения компьютера достаточно просто подсоединить кабель питания. Для выключения 
используйте штатную функцию операционной системы.

****
### Сборка примера

Приступим к продолжению сборки нашего демо-примера. Мы уже научились отправлять значения датчиков по радиоканалу. Теперь нам необходимо 
научится принимать эти данные, причем не путая их с чужими!

Нам необходимо следующее оборудование:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry03.png)

Берем Raspberry и аккуратно достаем карту памяти из прозрачного бокса.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry04.png)

Прежде всего нужно установить SD-карту с операционной системой Raspbian в соответствущее гнездо на плате Raspberry. В гнезде плата фиксируется 
благодаря блокирующему механизму. Для надежного закрепления нужно аккуратно вдавить пальцем карту в гнездо.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry05.png)

Raspberry должна принимать данные с Arduino по радиоканалу, поэтому нам нужно установить на нее приемник.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry06.png)

Подключение осуществляется согласно распиновке датчика: красный провод (+) - 2-ой пин, черный (земля) - 3-ий, а желтый (сигнал) - 13-ый 
(GPIO27). Белый провод не используется.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry07.png)

Должно получиться вот так:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry08.png)

Для нашего примера необходимо также подключить пьезоизлучатель.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry09.png)

Подключение осуществляется по схеме: красный провод (+) - 4-ый пин, черный (земля) - 14-ый пин, а желтый (сигнал) - 15-ый (GPIO22). Белый 
провод не используется.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry10.png)

Raspberry будет требоваться доступ в интернет для связи с серверами IBM, поэтому мы должны подключить ethernet-кабель в соответствующее 
гнездо. 
Кроме того, мы будем подключаться к плате через SSH соединение.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry11.png)


![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry12.png)

Питание платы осуществляется через mini-usb провод.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry13.png)

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspberry14.png)

***
### Настройка SSH соединения с Raspberry Pi

Используя ОС Linux выполнить подключение к RPi можно следующим образом:
```
ssh pi@XX.XX.XX.XX
```
где XX.XX.XX.XX - ранее определенный ip адрес устройства. 

Если вы работаете в ОС Windows, то вам нужно воспользоваться программой Putty.
В поле Имя хоста указываем ip адрес Raspberry в сети, порт 22 и тип подключения SSH.

Пароль пользователя pi: raspberry

***
### Полезные команды для работы в ОС Raspbian

-   "top" — запуск предустановленного в Raspbian диспетчера задач;
-   "sudo raspi-config" — запуск первоначального меню настроек;
-   "sudo passwd root" — создание пароля для пользователя root;
-   "startx" — запуск графической оболочки;
-   "sudo halt" — выключение RPi;
-   "logout" — выход из системы;
-   "sudo reboot" — перезагрузка RPi;
-   "cd" — переход в необходимую директорию, например, для перехода в директорию /etc/network/ - "cd /etc/network/"
-   "pwd" — путь до текущей директории;
-   "dir" — содержимое текущей директории;
-   "mkdir" — создание директории. Например, "mkdir /home/pitest/" создаст директорию "pitest";
-   "rmdir" — удаление директории. Например, "mdir /home/pitest/" - удаление директории "pitest";
-   "cat" — открыть файл для чтения. Например, "cat /etc/network/interfaces" покажет содержимое файла "interfaces";
-   "nano" — открыть файл для редактирования. Например, "nano
-   /etc/network/interfaces" откроет для редактирования файл "interfaces";
-   "ifconfig" — отобразит текущую конфигурацию сети;
-   "df" — выведет в консоли свободное и используемое дисковое пространство для всех разделов файловой системы;
-   "clear" — очистить экран терминала;
-   "Ctrl"+"Ins" — скопировать выделенное (текст);
-   "Shift"+"Ins" — вставить из буфера (текст);
-   "sudo" — выполнения команд c правами root пользователя. Например, это актуально, если вы зашли под пользователем "pi" и хотите из консоли 
отредактировать какой-нибудь системный файл - "sudo nano путь_до_файла";
-   "Ctrl"+"C" — остановка текущего действия/выход из консольного приложения;
-   "sudo apt-get update" — обновление списка доступных пакетов;
-   "sudo apt-get upgrade" — обновление установленных пакетов;
-   "sudo apt-get install" — установка необходимого пакета. Например, для
установки консольного браузера Links вводим "sudo apt-get install links".

***
### Программирование

В качестве языка программирования выбран Python из-за своего удобства работы как с датчиками, так и с серверами Bluemix.

в консоли SSH соединения с Raspberry делаем последовательно следующее:

Переход в ваш домашний каталог
```
cd ~
```
Создание папки для Хакатона
```
mkdir iot
```
Создание файла, в который будем писать код на Python и открытие его в стандартном редакторе nano.
```
nano raspberry.py
```

Теперь можем приступать к написанию программы. Полный код расположен после этого блока.

Данный раздел посвящён коммуникации с Arduino и Bluemix со стороны Raspberry Pi, для чего мы напишем скрипт на python. К сожалению, придётся использовать python 2 из-за библиотеки `pi_switch`.


### Получение данных с Arduino <a name="30"></a>
Для начала необходимо получить данные по радиоканалу. Вспомним формат передаваемых данных:
```
+----------+-----------+---------+
| group id | sensor id |  data   |
|  8 bits  |   8 bits  | 16 bits |
+----------+-----------+---------+
|<----------- 32 bits ---------->|
```

Для работы с радиоканалом нам потребуется использовать библиотеку `pi_switch`:
```python
from pi_switch import RCSwitchReceiver

receiver = RCSwitchReceiver()
receiver.enableReceive(2)
  ```

Так как нас интересует далеко не вся информация, необходимо перед декодированием пакета проверять номер группы:
```python
def check_group(packet):
    return (packet >> 24) == GROUP_ID
```

Так же нам потребуется функция для декодирования пакета, т.е. извлечения идентификатора датчика и данных с этого датчика. Данные с датчика хранятся в дополнительном коде, что необходимо учесть:
```python
def decode(packet):
    sid = (packet >> 16) & 0xff
    data = packet & 0xffff

    # Преобразование отрицательного значения.
    if data & 0x8000:
        data = data - 0x10000
    return sid, data
```

Взаимодействие с библиотекой происходит в неблокирующем стиле: данные накапливаются во внутреннем буфере, пока пакет не будет полностью получен, после чего данные могут быть обработаны:
```python
def receive_if_available():
    # Проверка наличия данных в буфере.
    if not receiver.available():
        return

    # Получение данных и сброс буфера.
    packet = receiver.getReceivedValue()
    receiver.resetAvailable()

    # Наш ли это пакет.
    if packet and check_group(packet):
        return decode(packet)
```


###Создание приложения в *Bluemix* <a name="31"></a>

Перейти по ссылке: https://bluemix.net/. Введите Ваш логин и пароль. Перейдите в раздел DASHBOARD. При необходимости создайте новое рабочнее пространство (например, `dev`).
![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix03.png)

Перейдите в раздел CATALOG.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix01.png)
**Рабочее поле Bluemix.**

Добавьте в проект компонент Internet of Things Foundation Starter. ![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix02.png)
В результате буду добавлены приложение SDK for Node.js  и сервис Cloudant NoSQL DB.


После этого добавьте в проект сервис IoT Foundation. ![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix04.png)
При создании в поле App укажите имя вашего приложения IoT Foundation Starter, что позволит автоматически связать SDK for Node.js с брокером MQTT.


Сервис IoT Foudation является интегрированным компонентом на основе брокера MQTT запросов. 
Для его использования необходимо выполнить конфигурацию брокера на прием пакетов от RaspberriPi.
Создадим описание нового устройства. В результате ваш проект будет иметь следующий вид.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix05.png)
**Рабочее поле Bluemix после довбавление IoT Foundation и IoT Foundation Starter.**

Перейдите в раздел DASHBOARD. Запустите конфигурирование сервиса IoT Foundation (Launch dashboard).
Далее добавьте новое устройство (Add Device). 
Создайте новый тип устройства (например, с именем: RPi). Все поля за исключением поля Name можно оставить пустыми.

Для добавления устройства созданного Вами типа понадобится определить уникальный DeviceID устройства (например, его mac адрес).

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix06.png)

В следующем окне Вы можете выбрать один из двух вариантов: использовать автоматически сгенерированный токен или добавить существующий токен устройства. Выберем первый вариант (оставьте поле token пустым). В результате Вам будет выдана информация о настройках устройства, которые необходимо сохранить для последующего использования (см. следующее задание).

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/bluemix07.png)


Полезной функцией IoT Foundation консоли является возможность просмотра логов сообщений MQTT. Данная возможность может быть использована для проверки работоспособности всей инфраструктуры, поиска ошибок и пр. 


### Отправка данных в *Bluemix* <a name="32"></a>
Для связи с Bluemix логично использовать протоколы, основанные на TCP или UDP. В данном примере используется MQTT.

После регистрации устройства в Bluemix мы получаем данные для авторизации, которые поместим в файл [device.cfg](src/device.cfg):
```ini
[device]
org=md8qpm
type=bmstu001
id=b827eb79051a
auth-method=token
auth-token=3BZu_drqRuAKH*K*+i
```

Bluemix предоставляет библиотеку ibmotf — небольшую обёртку над MQTT, инициализация соединения с которой выглядит как:
```python
import ibmiotf.device

def connect(config):
    options = ibmiotf.device.ParseConfigFile(config)
    client = ibmiotf.device.Client(options)
    client.connect()
    return client

client = connect('device.cfg')
```

После открытия соединения можно передавать данные, публикуя события:
```python
sid_to_topic = ['temperature', 'angle']

def send_data(sid, data):
    topic = sid_to_topic[sid]
    client.publishEvent(topic, 'json', data)
```

Теперь мы можем отправлять данные в облако по MQTT, получаемые с arduino по 433MHz-радиоканалу:
```python
def main():
    while True:
        payload = receive_if_available()
        if payload:
            sid, data = payload
            if 0 <= sid <= 1:
                send_data(sid, data)
            else:
                time.sleep(0.1)
```

Стоит заметить, что ждать необходимо только в отсутствии данных. Действительно, если ждать при любом исходе, то это может привести к накапливанию в буфере ненужных пакетов (полученных по ошибке) или в результате задержки на самой arduino.

### Получение данных из *Bluemix* <a name="33"></a>

В нашем случае нажатие на кнопку в веб-интерфейсе приведёт к гудку через динамик, подключённый к raspberry. Для работы с ним воспользуемся библиотекой `RPIO`.

Сконфигурируем GPIO-порт:
```python
import RPIO

BUZZER = 22
RPIO.setup(BUZZER, RPIO.OUT, initial=RPIO.LOW)
```

Теперь необходимо подписаться на получение данных из Bluemix:
```python
def connect(config):
    # ...
    client.commandCallback = on_message
    return client

def on_message(cmd):
    if cmd.command != 'button':
        return

    RPIO.output(BUZZER, 1)
    time.sleep(.05)
    RPIO.output(BUZZER, 0)

    print cmd
```

При инициализации соединения библиотека создаёт отдельный поток, в котором ожидаются поступающие события, называемые командами. После получения команды вызывается наш обработчик.

Полный код доступен [здесь](src/raspberry.py).
## Визуализация <a name="34"></a>
### Сервер <a name="35"></a>

Из рабочего пространства проекта перейдите в приложение SDK for NODE.js. В левом верхнем углу нажмите на ссылку для перехода в SDK NodeRED.
Дальнейшие действия поясняют процесс создания приложений в данном SDK.

Точкой входа в веб-приложение является файл `index.html`, для получения которого браузер выполняет http-запрос к нашему серверу. Поэтому нам необходимо воспользоваться node-red узлами `input/http` и `output/http`:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/static-server.png)
**Статический сервер.**

Теперь вход в приложение может быть осуществлён по адресу http://YOU_PROJECT_NAME.eu-gb.mybluemix.net/index.html (например, [http://example-hack.eu-gb.mybluemix.net/index.html](http://example-hack.eu-gb.mybluemix.net/index.html)).

Содержимое `index.html` и `index.js` подробно рассматривается в следующем разделе. Полный код: [index.html](src/index.html) и [index.js](src/index.js). Полный исходник всех потоков доступен [здесь](src/flows.json).

Теперь нам необходимо настроить взаимодействие с raspberry, т.е. получение и отправку данных. Для этого используется node-red узлы `input/ibmiot` и `output/ibmiot`:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspi-input.png)
**Настройки узла `input/ibmiot`.**

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raspi-output.png)
**Настройки узла `output/ibmiot`.**

Теперь мы можем взаимодействовать с raspberry:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/raw-data.png)
**Получение и отправка данных.**

Узел трансформации `transform` просто преобразует данные для пересылки клиенту:
```javascript
msg.payload = {
    topic: msg.eventType,
    data: msg.payload
};

return msg;
```

### Клиент <a name="36"></a>
В данном разделе рассмотрим вопрос реализацию визуализации на клиенте.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/webclient.png)
**Визуализация потоковых данных.**

В ответ на запрос `index.html`, сервер отдаёт страницу, в которой содержатся:

1. Ссылка на библиотеку для рисования графиков:
  ```html
  <script src="//cdnjs.cloudflare.com/ajax/libs/canvasjs/1.7.0/canvasjs.min.js"></script>
  ```
2. Ссылка на наш код, получающий данные:
  ```html
  <script src="index.js" defer></script>
  ```
3. Некоторые элементы, используемые в скрипте:
  ```html
  <div id="graph"></div>
  <div>Angle: <span id="angle">??</span>°</div>
  <input type="button" id="turn-btn" value="Turn on">
  ```

Рассмотрим подробнее логику клиента.

Для начала необходимо получить данные с bluemix. Для этого мы открываем сокет:
```javascript
var socket = new WebSocket('ws://' + window.location.host + '/data');
```

Теперь нам потребуется обработчик поступающих данных:
```javascript
socket.onmessage = function(e) {
  var item = JSON.parse(e.data);

  switch (item.topic) {
    case 'temperature':
      processTemp(item.data);
      break;
    case 'angle':
      processAngle(item.data);
      break;
  }
};
```

#### График температуры <a name="37"></a>
После получения актуальной температуры необходимо отобразить новое значение на графике:
```javascript
var $graph = document.querySelector('#graph');

// Массив, содержащий все точки.
var actual = [{x: new Date}];

var chart = new CanvasJS.Chart($graph, {
  axisX: {title: "Timeline"},
  axisY: {title: "Temperature"},
  data: [{
    type: "spline",
    dataPoints: actual
  }]
});

chart.render();

function processTemp(temp) {
  var now = new Date;

  // Будем хранить только последние две минуты.
  if (+now - actual[0].x > 2 * 60 * 1000)
    actual.shift();

  var point = {x: now, y: temp};
  actual.push(point);
  chart.render();
}
```

#### Угол поворота <a name="38"></a>
После получения актуального значения угла достаточно просто обновить элемент:
```javascript
var $angle = document.querySelector('#angle');

function processAngle(angle) {
  $angle.innerHTML = angle;
}
```

#### Кнопка <a name="39"></a>
При нажатии на кнопку нам важен сам факт нажатия, поэтому достаточно посылать `true`:
```javascript
var $button = document.querySelector('#turn-btn');
$button.onclick = function() {
  socket.send(true);
};
```
## Аналитическая обработка данных <a name="40"></a>
В этой части проекта необходимо выполнить статистическую обработку получаемых данных. Для этого потребуются следующие компоненты инфраструктуры:

- В платформе Bluemix реализовать сервис хранения данных в БД dashDB.
- Разработать структуру таблиц базы данных и SQL скрипты для добавления новых данных и удаления устаревших данных.
- Разработать поток Node-Red, реализующий запуск SQL скриптов.
- Выполнить проверку работоспособности потока с использованием консоли административной косноли dashDB.
- Выполнить разработку аналитического скрипта на языке R в среде RStudio.
- Разработать потока обработки Node-Red для запуска R скрипта.

Дополнительная информация:

[Язык программирования R](https://ru.wikibooks.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_R)

[Краткая справка по командам языка R](https://cran.r-project.org/doc/contrib/Short-refcard.pdf)

[Описание IDE RStudio](http://r-analytics.blogspot.ru/p/rstudio.html#.VuiE7x_fVNA)

[Инструкции определения данных на языке DDL](https://msdn.microsoft.com/ru-ru/library/cc879262%28v=sql.120%29.aspx)

[Краткий справочник по командам SQL](http://4its.ru/html/sql-commands.html)


### Работа с сервисом dashDB <a name="41"></a>
К началу этапа рабочая область проекта представляет собой три взаимосвязанных компонента:
- Сервис IoT Foundation для реализации функций брокера MQTT.
- Сервис CloudantDB для хранения настроек IoT Foundation и Node-Red.
- Приложения JavaScript в Node-Red сервере приложений.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics01.png)
**Рабочая область проекта.**

Сервис dashDB представляет собой интегрированные компоненты для реализации функций хранения и аналитической обработки данных с помощью языка R. Сервис позволяет создавать и контролировать состояние SQL базы данных dashDB, содержит набор готовых скриптов на языке R, позволяет создавать и отлаживать пользовательские скрипты.

#### Добавление сервиса в проект <a name="42"></a>
Выполним добавление сервиса dashDB.
На вкладке Catalog в секции Data and Analythics необходимо выбрать сервис dashDB.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics02.png)
**Добавление сервиса dashDB.**

В следующем окне вводятся поля Dev, App, Service. Все поля кроме App можно оставить без изменений. В поле App в выпадающем списке выберете имя вашего приложения Node-Red. Cвязывание позволит выполнять обращения к dashDB со стороны приложений Node-Red (можно выполнить связывание позднее).

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics03.png)
**Связывание dashDB с приложением Node-Red.**

Нажмите кнопку Create. После создания сервиса появится возможность перейти в консоль управления. Для этого нажмите на кнопку Launch.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics04.png)
**Консоль управления dashDB.**

Для работы с сервисом необходимо определить параметры:

* ***User ID***
* ***Host name***
* ***Password***

Указанная информация доступна на вкладке Connect в пункте Connect Information. Указанная информация понадобится впоследствии.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics05.png)
**Параметры для подключения к сервису dashDB.**


#### Создание таблицы <a name="43"></a>
На вкладке Tables объединены функции управления структурой базы данных. При создании сервиса автоматически создается новая база с именем, совпадающим с полем User ID (в примере: DASH105325).

Добавим в базу таблицу `TEMP` для хранения данных.

Для этого необходимо выбрать пункт Add Table и в открывшемся окне ввести код DDL.

```sql
CREATE TABLE TEMP (
  TIME BIGINT NOT NULL PRIMARY KEY,
  TEMP DOUBLE NOT NULL
);
```

Поле `TIME` предусмотрено для хранения метки времени.


#### Запуск потоковой записи первичных данных <a name="44"></a>
В приложении Node-Red необходимо связать блок IoT Foundation с функциональными блоками, формирующими структуру объекта payload, после чего передать его в блок `output/dashdb`. В блоке dashDB указать поле Service dashDB-xx (название сервиса dashDB).

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics06.png)
**Поток обработки для записи данных в dashDB.**

Обратите внимание, что в функциональных блоках название ключей в структуре payload должно совпадать с полями таблицы базы данных.

Например:
```js
msg.payload = {
  TIME: Date.now(),
  TEMP: msg.payload
};

return msg;
```

Проверим работоспособность приложения (кнопка Deploy). В консоли управления dashDB на вкладе Tables выберете таблицу TEMP и Browse Data.
Данные от сенсоров должны быть выбаны на экран.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics07.png)
**Проверка работоспособности скриптов SQL в консоли dashDB.**


#### Удаление данных из таблиц <a name="45"></a>
Все полученные данные накапливаются в таблице TEMP. Так как время аналитической обработки зависит от объемов данных, выполним удаление устаревших строк из таблиц. Для этого добавим следующий поток обработки, содержащий SQL скрипты

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics12.png)
**Удаление устаревших данных из таблиц dashDB.**

Скрипт для удаления данных старше одного часа:
```sql
DELETE FROM TEMP WHERE TIME <= (SELECT MAX(TIME) FROM TEMP) - 3600000;
```


#### Создание скрипта в RStudio <a name="46"></a>
В консоли dashDB перейти в пункты Analythics и далее R Scripts.
Выбрать пункт RStudio.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics08.png)
**Ввод User ID и Password для входа в RStudio.**

В результате будет открыто окно RStudio, в котором может выполняться пошаговая отладка команд на языке R.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics09.png)
**Окно среды RStudio.**

Подробнее о работе с IDE RStudio можно узнать [тут](http://r-analytics.blogspot.ru/p/rstudio.html#.VuiE7x_fVNA)

Выполним следующий скрипт (скрипт может быть вставлен в окно Console):

```R
library(ibmdbR)
mycon <- idaConnect("BLUDB", "", "")
idaInit(mycon)

# Загрузить данные из таблицы (запись данных в таблицу осуществляется также SQL запросом) 
data <- idaQuery('SELECT TIME, TEMP from TEMP', as.is = FALSE)
fit <- lm(TEMP ~ TIME, data)

# Предсказать на минуту вперёд 
new <- data.frame(TIME = max(data$TIME) + 60000)
new$TEMP = predict(fit, new)

cat(new$TEMP)

```

В результате скрипт будет выполнен, а все использованные фреймы могут быть проанализированы на вкладке Environment.


#### Запись скрипта в файловую систему окружения dashDB <a name="47"></a>
Для автоматического запуска разработанного скрипта необходимо сохранить его в рабочем пространстве проекта. Для этого необходимо перейти в консоль управления dashDB в пункт Analythics и пункт RScripts. Далее необходимо создать новый скрипт (+) и выполнить вставку кода R. Сохраним скрипт под именем predict.r.

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics10.png)
**Запись скрипта.**

Также можно выполнить тестовый запуск скрипта, нажав на кнопку Submit.


### Запуск скрипта по расписанию из node-red <a name="48"></a>

В редакторе NodeRed создайте следующий поток:

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics11.png)
**Запуск скрипта по расписанию.**

`URI creator` нужен для составления запроса:
```javascript
var source = encodeURIComponent('source("~/predict.r")');
msg.payload = 'cmd=RScriptRunScript&command='
            + source
            + '&fileName=&profileName=BLUDB&userid=dash107216';
msg.headers = {'content-type': 'application/x-www-form-urlencoded'};
return msg;
```

В данном коде необходимо заменить dash107216 на user ID пользователя dashDB (например DASH015794).


![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/analytics13.png)
**Узел запроса.**

В данном узле необходимо выбрать способ аутентификации ([v] Use basic authentication?), в поле URL выставить правильный host name адрес dashDB приложения,  в полях Username и Password указать значения user ID и password из настроек dashDB. Интервал запуск задается в начальном узле. Для этого в поле Repeat нужно указать временной интервал между генерацией сообщений (например, 20 секунд).

### Визуализация предиктивных данных <a name="49"></a>
Разумно отображать предиктивную прямую на том же графике, что и актуальную информацию о температуре.

Добавим в функцию `socket.onmessage` обработку потока предиктивных данных:
```javascript
switch (item.topic) {
  case 'temperature':
    // ...
  case 'predicted':
    processPredicted(item.data);
    break;
}
```

И добавим поток в инициализацию библиотеки для графиков:
```javascript
var actual = [{x: new Date}];
var predicted = [];

var chart = new CanvasJS.Chart($graph, {
  axisX: {title: "Timeline"},
  axisY: {title: "Temperature"},
  data: [{
    type: "spline",
    dataPoints: actual
  }, {
    type: "line",
    dataPoints: predicted,
    lineThickness: 1,
    lineDashType: 'dashDot'
  }]
});
```

Будем отображать предиктивные данные как прямую от текущей точки к предсказанной. Поэтому `predicted` всегда будет содержать только две точки. Предсказанная точка корректируется каждый раз при поступлении новых предиктивных данных:
```javascript
function processPredicted(temp) {
  predicted[1] = {
    x: new Date(Date.now() + 60 * 1000),
    y: temp
  };

  chart.render();
}
```

А текущая (`predicted[0]`) при поступлении актуальных:
```javascript
function processTemp(temp) {
  // ...
  actual.push(point);
  predicted[0] = point;

  chart.render();
}
```

![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/webclient-predicted.png)
**Результат визуализации.**
****

### Описание оборудования лаборатории Интернета вещей <a name="50"></a>



Датчик | Краткое описание | Варианты применения | Ссылка на документацию | Картинка
------------ | ------------- | ------------- | ------------- | -------------
Датчик газа|Датчик определяет присутствие сжиженного нефтяного газа, природного газа, газа в угольных пластах|Детектор утечки газа|http://www.waveshare.com/wiki/MQ-5_Gas_Sensor| ![](http://www.waveshare.com/w/thumb.php?f=MQ-5-Gas-Sensor_l.jpg&width=300)
Датчик цвета|Датчик обнаруживает статический свет,позволяет распознать оттенок цвета объекта, расположенного перед ним или цвет окружающего освещения.|Сортировка по цвету, зондирование окружающего света и калибровка, чтение тест ленты, подбор цветов.|http://www.waveshare.com/wiki/Color_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Color-Sensor_l.jpg&width=300)
Датчик пламени|Датчик пламени позволяет фиксировать наличие пламени или другого источника световых волн длиной 760 – 1100 нм в прямой видимости перед собой. |Детектор пожара, противопожарные роботы, пожарная сигнализация.|http://www.waveshare.com/wiki/Flame_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Flame-Sensor_l.jpg&width=300)
Датчик Холла|Датчик позволяет определить факт приближения магнита к датчику и определить полюса магнита.|В смартфонах и планшетах применяется для использования обложек типа Smart Cover – позволяет отключать экран при приближении к нему встроенного в обложку магнита.|http://www.waveshare.com/wiki/Hall_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Hall-Sensor_l.jpg&width=300)
Датчик ИК отражающий|Датчик испускает инфракрасный сигнал и затем ловит отражение этого инфракрасного сигнала от поверхности.|Счетчик трубопровода, отслеживание пути, обнаружение препятствий.|http://www.waveshare.com/wiki/Infrared_Reflective_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Infrared-Reflective-Sensor_l.jpg&width=300)
Датчик лазерный|Датчик позволяет обнаруживать объекты на расстоянии до 4-5 метров от места установки датчика.|Обнаружение препятствий и уклонение от них на роботах и автомобилях, в качестве элемента счетчика готовых изделий на конвейере.|http://www.waveshare.com/wiki/Laser_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Laser-Sensor_l.jpg&width=300)
Датчик влажности|Датчик определяет влажность земли, в которую он погружен.|Применяется в автоматических системах полива и системах обнаружения влаги. |http://www.waveshare.com/wiki/Moisture_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Moisture-Sensor_l.jpg&width=300)
Датчик вращения|Датчик позволяет оценить возможности установленного энкодера для определения направления движения его оси, угла поворота и количества оборотов.|Позиционирование в индустриальных системах управления.|http://www.waveshare.com/wiki/Rotation_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Rotation-Sensor_l.jpg&width=300)
Датчик звука|Датчик  предназначен для обнаружения интенсивность звука в окружающей среде.|Голосовой выключатель|http://www.waveshare.com/wiki/Sound_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Sound-Sensor_l.jpg&width=300)
Датчик температуры и влажности|Датчик измеряет температуру и влажность окружающего воздуха.|На метеостанциях, в качестве контроллера влажности.|http://www.waveshare.com/wiki/Temperature-Humidity_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Temperature-Humidity-Sensor_l.jpg&width=300)
Датчик наклона|Датчик предназначен для определения наклона или вибрации объекта, на котором установлена плата датчика.|Детекторы встряски, охранные сигнализации, умный автомобиль.|http://www.waveshare.com/wiki/Tilt_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Tilt-Sensor_l.jpg&width=300)
Датчик УФ|Датчик предназначен для исследования спектра излучения в диапазоне волн 200...370 нм.|Тестирование ультрафиолетового излучения, бактерицидные лампы и др.|http://www.waveshare.com/wiki/UV_Sensor|![](http://www.waveshare.com/w/thumb.php?f=UV-Sensor_l.jpg&width=300)
Датчик уровня жидкости|Датчик предназначен для детектирования уровня жидкости. Результаты - в виде изменения сопротивления, которое соответствует расстоянию от верха датчика до поверхности жидкости. Сопротивление обратно пропорционально высоте столба жидкости.| Датчик уровня воды, датчик утечки воды.|http://www.waveshare.com/wiki/Liquid_Level_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Liquid-Level-Sensor_l.jpg&width=300)
Датчик угла поворота|Датчик определяет значение угла, на который он повернут.|Контроль положения вращающихся механизмов, управление двигателями, контроль натяжения, робототехника.|http://www.seeedstudio.com/wiki/Grove_-_Rotary_Angle_Sensor|![](http://www.seeedstudio.com/wiki/images/thumb/a/af/Grove_-_Rotary_Angle_Sensor_%28P%29.jpg/400px-Grove_-_Rotary_Angle_Sensor_%28P%29.jpg)
Датчик температуры|Датчик измеряет температуру окружающей среды.|Контроль состояния оборудования.|http://www.seeedstudio.com/wiki/Grove_-_Temperature_Sensor|![](http://www.seeedstudio.com/wiki/images/thumb/b/b0/Temperature1.jpg/400px-Temperature1.jpg)
Датчик света|Датчик используется для обнаружения света окружающей среды и определения его интенсивности.|Система автоматического включения/выключения света в зависимости от освещенности и др.|http://www.seeedstudio.com/wiki/Grove_-_Light_Sensor|![](http://www.seeedstudio.com/wiki/images/thumb/1/1c/Twig-Light.jpg/500px-Twig-Light.jpg)
Датчик, сочетающий в себе гироскоп, акселерометр, магнетометр и барометр.|Датчик отслеживает движение и атмосферное давление.|Системы навигации, шагомеры, определение положения в пространстве и т. д.|http://www.seeedstudio.com/wiki/Grove_-_IMU_10DOF|![](http://www.seeedstudio.com/wiki/images/thumb/5/5a/Grove-imu-10dof.JPG/400px-Grove-imu-10dof.JPG)
Приемник + передатчик 433МГц для Arduino проектов|Набор для беспроводной связи на частоте 433МГц, включает в себя модуль передатчика и модуль приемника. Конфигурация антенны позволяет прим/передачу в помещение на расстояние до 40 метров, на улице около 100 метров.|Для реализации дистанционного управления роботами, устройств автоматизации. |http://www.seeedstudio.com/wiki/Grove_-_433MHz_Simple_RF_link_kit|![](http://www.seeedstudio.com/wiki/images/thumb/9/94/433MHz_Simple_RF.jpg/400px-433MHz_Simple_RF.jpg)
Модуль Wi-Fi|WiFi модуль на базе чипа ESP8266 для Arduino проектов.|Медицинское обслуживание, умные дома, автоматизация зданий.|http://www.seeedstudio.com/depot/WT8266S1-FCCCERoHS-WiFi-Module-based-on-ESP8266-p-2521.html|![](http://www.seeedstudio.com/depot/bmz_cache/a/ac52f926c6f75f6539ed12012c5a8150.image.200x150.jpg)
Ультразвуковой приемопередатчик|Ультразвуковой датчик для измерения расстояния и обнаружения предметов в диапазоне от 2 сантиметров до 4метров. |Проектирование и строительство зданий, возможность замерять пройденное расстояние.|http://www.micropik.com/PDF/HCSR04.pdf|![](http://robocraft.ru/files/sensors/Ultrasonic/HC-SR04/hc-sr04_.jpg)
Монитор воздуха (датчик пыли)|Обнаруживает частицы диаметром более 0.8мкм, в том числе сигаретный дым. |Датчики этого типа широко применяются в качестве детекторов PM2.5 частиц, воздухоочистителях, кондиционерах, мониторах воздуха и т.д|http://www.waveshare.com/wiki/Dust_Sensor|![](http://www.waveshare.com/w/thumb.php?f=Dust-Sensor-intro.jpg&width=300)
Цифровой датчик температуры и влажности|Датчик измеряет температуру и влажность окружающего воздуха.|Автоматизированная теплица, умный дом.|http://files.amperka.ru/datasheets/dht11.pdf|![](http://lib.chipdip.ru/426/DOC001426899.jpg)
Датчик шума аналоговый|Датчик выдаёт аналоговый сигнал в диапазоне 0-5 В. Выходное напряжение пропорционально средней шумности за последние несколько сотен миллисекунд.|Датчик можно использовать для разработки замка, открываемого кодовым стуком, изучения качества шумоизоляции, в охранных системах, или чтобы измерить интенсивность аплодисментов после вашего выступления.|http://wiki.amperka.ru/%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82%D1%8B:troyka:sound-loudness-sensor|![](http://wiki.amperka.ru/_media/%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82%D1%8B:troyka:loudness:loudness-sensor.jpg)
Датчик влажности почвы|Датчик определяет влажность земли, в которую он погружен.|Применяется в автоматических системах полива и системах обнаружения влаги. |http://amperka.ru/product/soil-moisture-sensor|![](http://static12.insales.ru/images/products/1/5919/40245023/soil-moisture-sensor.0.jpg)
Пьезо датчик вибрации|Пьезоэлектрический датчик удара (вибрации) с кабелем и резистором нагрузки.|Контроль состояния оборудования.|https://www.olimex.com/Products/Breadboarding/PIEZZO-KNOCK/|![](https://www.olimex.com/Products/Breadboarding/PIEZZO-KNOCK/images/thumbs/310x230/PIEZZO-KNOCK.jpg)
Плата датчика ультразвукового сонара|Ультразвуковой датчик для обнаружения предметов в диапазоне от 3 сантиметров до 4метров.|Системы скрытого обнаружения; робототехника; дальномеры.|http://www.seeedstudio.com/wiki/Grove_-_Ultrasonic_Ranger|![](http://www.seeedstudio.com/depot/bmz_cache/5/5e1308c71a5a1ba04dd6bfda52bd7948.image.530x397.jpg)
Программируемый контроллер на основе МК ATmega328 + Grove интерфейс|Seeeduino Lotus это плата сочетающая в себе программируемый контролер Seeeduino на базе микроконтроллера ATmega328 и плату Base Shield для подключения датчиков серии Grove. |Аналог Arduino UNO|http://www.seeedstudio.com/wiki/Seeeduino_Lotus_v1.0|![](http://www.seeedstudio.com/depot/bmz_cache/6/614961cf3e7fff1bd1c49a9a8853b4cb.image.530x397.jpg)
Приемник + передатчик 433МГц |Набор для беспроводной связи на частоте 433МГц, включает в себя модуль передатчика и модуль приемника. Конфигурация антенны позволяет прим/передачу в помещение на расстояние до 40 метров, на улице около 100 метров.|Дистанционное управление роботами, устройства автоматизации.|http://www.seeedstudio.com/wiki/Grove_-_433MHz_Simple_RF_link_kit|![](http://www.seeedstudio.com/depot/bmz_cache/5/5f6b35060290665635868b2a6394134b.image.530x397.jpg)
Пассивный зуммер KY-006|Модуль с пассивным динамиком-пищалкой создает различные шумы основанные на различной частоте ввода / вывода.|Модуль широко используемые в компьютерах , принтерах, сигнализациях, электронных игрушках, автомобильном электронном оборудовании, телефонах, таймерах и других звуковых электронных устройствах.|http://learn.linksprite.com/arduino/sensors-kit-for-arduino/ky006-buzzer-module/|![](https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcT_XjCmy2MqWKe2ccODLyaPJrkoQe2WX8t2OmU7kcLFygUpkYRVVTS2IPI)
Активный зуммер KY-012|Модуль зуммер пищалки звука, акустический датчик звуковой сигнала активный для ардуино Arduino Buzzer KY-012|Модуль активного звукового излучателя работает при напряжение 5 В. Совместим с ПК, принтерами, аудио системами автомобилей DIY.|https://tkkrlab.nl/wiki/Arduino_KY-012_Active_buzzer_module|![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/modul-buzzer-ky-012-175564087.jpg)
Двухцветный светодиод KY-029|KY-029 Yin Yi модуль с 2-х цветным светодиодом с общим катодом (зеленый и красный) 3MM На плате распаян резистор и зачем-то smd светодиод подключение через токоограничительные резисторы|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-029_Yin_Yi_2-color_LED_module_3MM|![](https://tkkrlab.nl/w/images/8/85/Arduino_KY-029_Yin_Yi_2-color_LED_module_3MM_Sku_135525_2.jpg)
Трехцветный светодиод KY-011|на плате распаян резистор и зачем-то smd светодиод подключение через токоограничительные резисторы|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-011_2-color_LED_module|![](https://tkkrlab.nl/w/images/2/25/KY-011_2-color_LED_module_2_color_led.PNG)
Трехцветный светодиод KY-009|Четыре вывода R,G,B и GND.Работаем как с обычными диодами, регулируя напряжения на каждом субпикселе получим нужный цвет пикселя.|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-009_3-color_full-color_LED_SMD_modules|![](https://tkkrlab.nl/w/images/thumb/5/59/Arduino_KY-009_3-color_full-color_LED_SMD_modules_Sku_135046.jpg/400px-Arduino_KY-009_3-color_full-color_LED_SMD_modules_Sku_135046.jpg)
Трехцветный светодиод KY-016|содержит RGB светодиод с 3-мя входами, что позволяет получать нужный цвет излучения с помощью подачи нужного напряжения на входы. Светодиод имеет общий катод. Ограничительные резисторы установлены на плате.|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-016_3-color_LED_module|![](https://tkkrlab.nl/w/images/thumb/a/ac/Arduino_KY-016_3-color_LED_module_Sku_135041_2.jpg/400px-Arduino_KY-016_3-color_LED_module_Sku_135041_2.jpg)
Семицветный светодиод KY-034|Автоматический модуль мерцающего света для ардуино KY-034 датчик arduino 7 color flash|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-034_Automatic_flashing_colorful_LED_module|![](https://tkkrlab.nl/w/images/thumb/d/d1/KY-034_Automatic_flashing_colorful_LED_module.PNG/400px-KY-034_Automatic_flashing_colorful_LED_module.PNG)
Датчик удара KY-031|Датчик детонации модуль и цифровой интерфейс, встроенный светодиодные сборки| Интерфейс поставляется с цифровой светодиод, датчик детонации. При определении удара светодиод мигает.|https://tkkrlab.nl/wiki/Arduino_KY-031_Sensor_module|![](https://tkkrlab.nl/w/images/thumb/a/ae/Arduino_KY-031_Sensor_module.PNG/400px-Arduino_KY-031_Sensor_module.PNG)
Вибровыключатель KY-002|Внутри модуля два шарика, при вибрации шарики прыгают по трубке, контакт размыкается. На плате уже распаян подтягивающий резистор для включения напрямую на цифровую ногу Arduino|Работает как обыкновенная кнопка|https://tkkrlab.nl/wiki/Arduino_KY-002_Vibration_switch_module|![](https://raw.githubusercontent.com/bmstu-hackathon/example/gh-pages/assets/datchik-udara-ky-002-133712001_small6.jpg)
Фоторезистор KY-018|При отсутствии света сопротивление фоторезистора большое и доходит до 1 мОм, а при его освещении падает до нескольких Ом. между «S» и 5 В впаян резистор 10 кОм, что вместе с самим фоторезистором образует делитель напряжения, который удобно подключить к аналоговому входу Arduino.|фоторезистор (датчик освещенности), который применяется для измерения интенсивности света или определения его наличия/отсутствия|https://tkkrlab.nl/wiki/Arduino_KY-018_Photo_resistor_module|![](https://tkkrlab.nl/w/images/thumb/2/27/Arduino_KY-018_Photo_resistor_module.PNG/400px-Arduino_KY-018_Photo_resistor_module.PNG)
Фоторезистор-выключатель KY-010|На выходе либо 1 либо ноль. Резисторы распаяны на плате|Датчик состоит из светодиода и фототранзистора. |https://tkkrlab.nl/wiki/Arduino_KY-010_Optical_broken_module|![](https://tkkrlab.nl/w/images/thumb/9/98/Arduino_KY-010_Optical_broken_module_Sku_135035_2.jpg/400px-Arduino_KY-010_Optical_broken_module_Sku_135035_2.jpg)
Кнопка KY-004|Нормально разомкнутая. На плате уже присутствует подтягивающий резистор, поэтому подключаем по трехточной схеме. ||https://tkkrlab.nl/wiki/Arduino_KY-004_Key_switch_module|![](https://tkkrlab.nl/w/images/thumb/a/a9/Arduino_KY-004_Key_switch_module_Sku_135511.jpg/400px-Arduino_KY-004_Key_switch_module_Sku_135511.jpg)
Датчик наклона KY-020|переключатель срабатывающий от наклона модуля, имеющий цифровой интерфейс.| При наклоне датчика в одну сторону контакты “-” и “S” замыкаются, при наклоне в другую размыкаются. Модуль позволяет определять только 2 положения и не измеряет угол наклона. Между контактами “ 5В” и “S” впаян резистор 10 кОм.|https://tkkrlab.nl/wiki/Arduino_KY-004_Key_switch_module|![](https://tkkrlab.nl/w/images/thumb/a/a9/Arduino_KY-004_Key_switch_module_Sku_135511.jpg/400px-Arduino_KY-004_Key_switch_module_Sku_135511.jpg)
Датчик наклона KY-017|Ртутный. На плате присутствуют помимо датчика резистор и светодиод|Работаем как с обычной кнопкой|https://tkkrlab.nl/wiki/Arduino_KY-017_Mercury_open_optical_module|![](https://tkkrlab.nl/w/images/a/a0/Arduino_KY-017_Mercury_open_optical_module.PNG)
Датчик инфракрасного излучения KY-005|На плате распаян резистор из расчета питающего напряжения 5V. |Работать как с обычным светодиодом|https://tkkrlab.nl/wiki/Arduino_KY-005_Infrared_emission_sensor_module|![](https://tkkrlab.nl/w/images/4/40/Arduino_KY-005_Infrared_emission_sensor_module_Sku_135040.jpg)
Инфракрасный датчик KY-022|На плате имеется светодиод с токоограничивающим резистором 1 кОм, которые включены между контактами 5 и “S”.|Модуль предназначен для приема данных по инфракрасному каналу от пультов управления. |https://tkkrlab.nl/wiki/Arduino_KY-022_Infrared_sensor_receiver_module|![](https://tkkrlab.nl/w/images/b/b6/Arduino_KY-022_Infrared_sensor_receiver_module_Sku_135045_2.jpg)
Датчик температуры KY-013|На выходе – напряжение, пропорциональное температуре. На плате термистор и резистор делителя. Сенсор - NTC термистор измеряет: -55°C / 125°C; точность: / — 0.5°C|Измеряет температуры|https://tkkrlab.nl/w/images/a/a0/Arduino_KY-017_Mercury_open_optical_module.PNG|![](https://tkkrlab.nl/wiki/Arduino_KY-013_Temperature_sensor_module)
Датчик температуры KY-028|Этот модуль имеет два выхода – цифровой и аналоговый. На плате имеется 2 светодиода – индикации питания и индикации выхода с компаратора. Построечным резистором можно изменять чувствительность датчика|Измеряет температуры|https://tkkrlab.nl/w/images/2/2c/KY013.jpg|![](https://tkkrlab.nl/wiki/Arduino_KY-013_Temperature_sensor_module)
Датчик температуры KY-001|Собран на цифровом сенсоре DS18B20, напряжение питания от 3.0 V до 5.5 V. Измеряемая температура -55 ° C до 125 ° C, по Фаренгейту — 67 ° F до 257 ° F. В диапазоне от -10 °C до 85 ° C точность измерения ± 0.5 ° C. Время измерения не более 750 миллисекунд. Каждый DS18B20 имеет уникальный номер, что позволяет подключить к одной шине большое количество датчиков|Измеряет температуры|https://tkkrlab.nl/wiki/Arduino_KY-001_Temperature_sensor_module|![](https://tkkrlab.nl/w/images/thumb/2/22/Arduino_KY-001_Temperature_sensor_module_Sku_135047_2.jpg/400px-Arduino_KY-001_Temperature_sensor_module_Sku_135047_2.jpg)
Датчик температуры и влажности KY-015|напряжение питания, В: 3.3…5 выход: цифровой диапазон измерения влажности, % RH: 20-90 диапазон измерения температуры, ℃: 0…50 точность измерения влажности, % RH: / – 5 точность измерения температуры, ℃: / – 2 разрешающая способность при измерении влажности, % RH: 1 разрешающая способность при измерении температуры, ℃: 1 долгосрочная стабильность, % RH / год: < ± 1 подключение левый пин S --> к выводу 10 ардуино Правый пин GND  Средний пин 5 |Измеряет температуры и влажность|https://tkkrlab.nl/wiki/Arduino_KY-015_Temperature_and_humidity_sensor_module|![](https://tkkrlab.nl/w/images/thumb/d/d9/Arduino_KY-015_Temperature_and_humidity_sensor_module_Sku_121350_1.jpg/400px-Arduino_KY-015_Temperature_and_humidity_sensor_module_Sku_121350_1.jpg)
Датчик звука KY-037|Плата с большим микрофоном, имеет 2 выхода: цифровой и аналоговый AO, аналоговый выход – сигнал напрямую с микрофона DO, цифровой выход – при превышении порога срабатывания на выходе 1. Чувствительность срабатывания регулируется подстроечным Резистором На плате два светодиода – один при подаче питания, второй при срабатывании цифрового выхода|Срабатывает при обнаружения звука|https://tkkrlab.nl/wiki/Arduino_KY-037_Sensitive_microphone_sensor_module|![](https://tkkrlab.nl/w/images/thumb/8/8d/Arduino_KY-037_Sensitive_microphone_sensor_module.PNG/400px-Arduino_KY-037_Sensitive_microphone_sensor_module.PNG)
Датчик металла KY-036|На плате два светодиода – питание и срабатывание датчика|сенсорный модуль имеет металлический контакт для определения касания человека.|https://tkkrlab.nl/wiki/Arduino_KY-036_Metal_touch_sensor_module|![](https://tkkrlab.nl/w/images/thumb/4/44/Arduino_KY-036_Metal_touch_sensor_module_Sku_121514_1.jpg/400px-Arduino_KY-036_Metal_touch_sensor_module_Sku_121514_1.jpg)
Датчик сердцебиения KY-039|состоит из инфракрасного светодиода (LED) и фототранзистора, с помощью которых можно измерять пульс в пальце. Монитор сердечного ритма работает следующим образом: палец должен быть расположен между IR светодиодом и фототранзистором, который получает поток инфракрасного излучения. Когда в пальце пульсирует кровь — сопротивление фототранзистора меняется. При измерениях пульса необходимо чтобы фототранзистор был защищен от попадания прямого солнечного или искусственного света для исключения нежелательных помех.| измерять пульс в пальце|https://tkkrlab.nl/wiki/Arduino_KY-039_Detect_the_heartbeat_module|![](https://tkkrlab.nl/w/images/7/7e/Arduino_KY-039_Detect_the_heartbeat_module.PNG)
Датчик пламени KY-026|Этот модуль имеет два выхода – цифровой и аналоговый. На плате имеется 2 светодиода – индикации питания и индикации выхода с компаратора. Построечным резистором можно изменять чувствительность датчика.|датчик пламени реагирует на инфракрасное излучение и наиболее чувствителен к длинам волн от 760 нм до 1100 нм. Этот модуль имеет два выхода – цифровой и аналоговый. На плате имеется 2 светодиода – индикации питания и индикации выхода с компаратора. Построечным резистором можно изменять чувствительность датчика.|https://tkkrlab.nl/wiki/Arduino_KY-026_Flame_sensor_module|![](https://tkkrlab.nl/w/images/thumb/8/8a/Arduino_KY-026_Flame_sensor_module_Sku_135038_2.jpg/400px-Arduino_KY-026_Flame_sensor_module_Sku_135038_2.jpg)
Геркон KY-021|Напаян подтягивающий резистор. Подключаем к контактам и – питание, средний вывод – выход кнопки. Работаем как с обычной кнопкой.|Контакт, срабатывающий при поднесении к нему магнита.|https://tkkrlab.nl/wiki/Arduino_KY-021_Mini_magnetic_reed_modules|![](https://tkkrlab.nl/w/images/thumb/6/65/Ky021.jpg/400px-Ky021.jpg)
Магнитный датчик KY-003|Собран на микросхеме 44E.Если магнитное поле отсутствует, на выходе S HIGH если магнитное поле в наличии – на выходе сигнал LOW и светодиод на датчике загорается. Чувствителен к полярности магнитного поля.|Контакт, срабатывающий при поднесении к нему магнита.|https://tkkrlab.nl/wiki/Arduino_KY-003_Hall_magnetic_sensor_module|![](https://tkkrlab.nl/w/images/thumb/7/79/Hall_sensor.PNG/400px-Hall_sensor.PNG)
Магнитный датчик KY-035|На выходе аналоговый сигнал, пропорциональный напряженности магнитного поля|Измерения магнитного поля|https://tkkrlab.nl/wiki/Arduino_KY-035_Class_Bihor_magnetic_sensor|![](https://tkkrlab.nl/w/images/thumb/8/84/Arduino_KY-035_Class_Bihor_magnetic_sensor.PNG/400px-Arduino_KY-035_Class_Bihor_magnetic_sensor.PNG)
Датчик магнитного поля KY-025|красный светодиод на плате при замыкании загорается в отличие от модуля с простым герконом у этой платы 4 вывода, на борту есть компаратор и светодиод.|Измерения магнитного поля|https://tkkrlab.nl/wiki/Arduino_KY-025_Reed_module|![](https://tkkrlab.nl/w/images/thumb/4/42/Arduino_KY-025_Reed_module.PNG/400px-Arduino_KY-025_Reed_module.PNG)
Датчик магнитного поля KY-024|Датчик имеет и цифровой и аналоговый выходы. На плате светодиод, который загорается при детектировании магнитного поля.|Измерения магнитного поля|https://tkkrlab.nl/wiki/Arduino_KY-024_Linear_magnetic_Hall_sensors|![](https://tkkrlab.nl/w/images/thumb/c/cc/Arduino_KY-024_Linear_magnetic_Hall_sensors.PNG/400px-Arduino_KY-024_Linear_magnetic_Hall_sensors.PNG)
Инфракрасный датчик приближения KY-033|При приближении препятствия срабатывает датчик, на выходе 1 и загорается светодиод на плате||https://tkkrlab.nl/wiki/Arduino_KY-033_Hunt_sensor_module|![](https://tkkrlab.nl/w/images/thumb/6/69/Arduino_KY-033_Hunt_sensor_module_Sku_118057_2.jpg/400px-Arduino_KY-033_Hunt_sensor_module_Sku_118057_2.jpg)
Модуль световых эффектов “магическая чашка” KY-027|Светодиод|Индикация|https://tkkrlab.nl/wiki/Arduino_KY-027_Magic_light_cup_module|![](https://tkkrlab.nl/w/images/thumb/1/17/Arduino_KY-027_Magic_light_cup_module_Sku_136115_1.jpg/400px-Arduino_KY-027_Magic_light_cup_module_Sku_136115_1.jpg)
Датчик угла поворота (энкодер) KY-040|По этому коду можно определить направление вращения. На полный оборот приходится 24 импульса. Помимо этого нажатие на ручку вызывает срабатывание кнопки.|Енкодер выдает при вращении двоичный код на двух выходах.|https://tkkrlab.nl/wiki/Arduino_KY-040_Rotary_encoder_module|![](https://tkkrlab.nl/w/images/f/f6/Arduino_KY-040_Rotary_encoder_module.PNG)
Датчик для избегания препятствий KY-032| Модуль KY-032 используется в качестве датчика препятствия. - Рабочая частота приемника: 38 kHz. - Рабочее напряжение - 3,3В/5В. - Рабочий ток - 20мА. - Имеет отдельный вход (EN)  для включения (0) или отключения (1) датчика (для активации этого входа необходимо снять перемычку на плате). - Выходной сигнал: уровень ТТЛ (низкий уровень - есть препятствие, нет препятствия - высокий). - Эффективный угол: 35 °. - Рабочая частота передатчика: регулируется потенциометром. - Расстояние обнаружения от 2см. до 40см.|используется в качестве датчика препятствия.|https://tkkrlab.nl/wiki/Arduino_KY-032_Obstacle_avoidance_sensor_module|![](https://tkkrlab.nl/w/images/thumb/3/39/Arduino_KY-032_Obstacle_avoidance_sensor_module.PNG/400px-Arduino_KY-032_Obstacle_avoidance_sensor_module.PNG)
Датчика звука KY-038|Плата с маленьким микрофоном, имеет 2 выхода: цифровой и аналоговый AO, аналоговый выход – сигнал напрямую с микрофона DO, цифровой выход – при превышении порога срабатывания на выходе 1. Чувствительность срабатывания регулируется подстроечным Резистором На плате два светодиода – один при подаче питания, второй при срабатывании цифрового выхода|Обнаружение звука|https://tkkrlab.nl/wiki/Arduino_KY-038_Microphone_sound_sensor_module|![](https://tkkrlab.nl/w/images/thumb/a/a3/Arduino_KY-038_Microphone_sound_sensor_module_Sku_135533_1.jpg/400px-Arduino_KY-038_Microphone_sound_sensor_module_Sku_135533_1.jpg)
Лазерный модуль KY-008|Параметры: 30 mA при 5 V Подключение пин — = GND Pin = 5V|Излучает лазерный луч|https://tkkrlab.nl/wiki/Arduino_KY-008_Laser_sensor_module|![](https://tkkrlab.nl/w/images/thumb/f/f3/Arduino_KY-008_Laser_sensor_module_Sku_137473.jpg/400px-Arduino_KY-008_Laser_sensor_module_Sku_137473.jpg)
Реле KY-019|Используется для коммутации нагрузки с большим напряжением или током. Например лампы|Преобразование напрежение и тока|https://tkkrlab.nl/wiki/Arduino_KY-019_5V_relay_module|![](https://tkkrlab.nl/w/images/thumb/c/c1/Arduino_KY-019_5V_relay_module_Sku_121354_1.jpg/400px-Arduino_KY-019_5V_relay_module_Sku_121354_1.jpg)
Джойстик KY-023|Двухосевой аналоговый джойстик с кнопкой|Для управления|https://tkkrlab.nl/wiki/Arduino_KY-023_XY-axis_joystick_module|![](https://tkkrlab.nl/w/images/thumb/a/a4/Arduino_KY-023_XY-axis_joystick_module_Sku_121340_3.jpg/400px-Arduino_KY-023_XY-axis_joystick_module_Sku_121340_3.jpg)

